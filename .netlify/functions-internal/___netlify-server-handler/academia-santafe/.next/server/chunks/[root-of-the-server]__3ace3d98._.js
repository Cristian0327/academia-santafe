module.exports=[18622,(e,t,r)=>{t.exports=e.x("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js",()=>require("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js"))},56704,(e,t,r)=>{t.exports=e.x("next/dist/server/app-render/work-async-storage.external.js",()=>require("next/dist/server/app-render/work-async-storage.external.js"))},32319,(e,t,r)=>{t.exports=e.x("next/dist/server/app-render/work-unit-async-storage.external.js",()=>require("next/dist/server/app-render/work-unit-async-storage.external.js"))},24725,(e,t,r)=>{t.exports=e.x("next/dist/server/app-render/after-task-async-storage.external.js",()=>require("next/dist/server/app-render/after-task-async-storage.external.js"))},93695,(e,t,r)=>{t.exports=e.x("next/dist/shared/lib/no-fallback-error.external.js",()=>require("next/dist/shared/lib/no-fallback-error.external.js"))},21564,e=>{"use strict";var t=e.i(91837),r=e.i(74614),a=e.i(24043),n=e.i(84193),o=e.i(7555),s=e.i(61325),i=e.i(45418),l=e.i(86634),p=e.i(11081),c=e.i(62380),d=e.i(92845),u=e.i(16291),x=e.i(89822),g=e.i(29439),h=e.i(23601),R=e.i(91759),f=e.i(93695);e.i(53832);var v=e.i(28552),m=e.i(1383);async function E(e){try{let{contenidoCurso:t,tiposPreguntas:r}=await e.json(),a=process.env.OPENAI_API_KEY;if(!a)return m.NextResponse.json({error:"API key de OpenAI no configurada"},{status:500});let n=(r.opcion2||0)+(r.opcion3||0)+(r.opcion4||0)+(r.opcion5||0);if(0===n)return m.NextResponse.json({error:"Debes especificar al menos una pregunta"},{status:400});let o=`Eres un experto en educaci\xf3n y evaluaci\xf3n. Genera preguntas de opci\xf3n m\xfaltiple basadas en el siguiente contenido del curso:

CONTENIDO DEL CURSO:
${t}

INSTRUCCIONES:
Genera exactamente ${n} preguntas distribuidas as\xed:
${r.opcion2>0?`- ${r.opcion2} pregunta(s) con 2 opciones`:""}
${r.opcion3>0?`- ${r.opcion3} pregunta(s) con 3 opciones`:""}
${r.opcion4>0?`- ${r.opcion4} pregunta(s) con 4 opciones`:""}
${r.opcion5>0?`- ${r.opcion5} pregunta(s) con 5 opciones`:""}

FORMATO DE RESPUESTA (JSON):
Responde \xdaNICAMENTE con un array JSON v\xe1lido sin texto adicional. Cada pregunta debe tener esta estructura exacta:
{
  "id": "numero \xfanico",
  "tipo": "multiple",
  "pregunta": "texto de la pregunta",
  "opciones": ["opci\xf3n 1", "opci\xf3n 2", ...],
  "respuestaCorrecta": \xedndice de la respuesta correcta (0-based),
  "retroalimentacion": "explicaci\xf3n breve de por qu\xe9 es correcta"
}

REQUISITOS IMPORTANTES:
1. Las preguntas deben ser claras y estar directamente relacionadas con el contenido
2. Las opciones incorrectas deben ser plausibles pero claramente incorrectas
3. La retroalimentaci\xf3n debe explicar por qu\xe9 la respuesta es correcta
4. Responde SOLO con el array JSON, sin markdown, sin explicaciones adicionales
5. Aseg\xfarate de que el JSON sea v\xe1lido y parseable`,s=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${a}`},body:JSON.stringify({model:"gpt-4o-mini",messages:[{role:"system",content:"Eres un experto en educación que genera preguntas de evaluación de alta calidad. Respondes ÚNICAMENTE con JSON válido, sin texto adicional."},{role:"user",content:o}],temperature:.7,max_tokens:2e3})});if(!s.ok){let e=await s.json();return console.error("Error de OpenAI:",e),m.NextResponse.json({error:"Error al comunicarse con OpenAI",details:e},{status:s.status})}let i=(await s.json()).choices[0].message.content.trim();i.startsWith("```json")?i=i.replace(/```json\n?/g,"").replace(/```\n?/g,""):i.startsWith("```")&&(i=i.replace(/```\n?/g,""));let l=JSON.parse(i);if(!Array.isArray(l))return m.NextResponse.json({error:"La respuesta de OpenAI no es un array válido"},{status:500});let p=l.map((e,t)=>({...e,id:e.id||`ia-${Date.now()}-${t}`}));return m.NextResponse.json({preguntas:p,total:p.length})}catch(e){return console.error("Error en generar-preguntas:",e),m.NextResponse.json({error:"Error interno del servidor",details:e instanceof Error?e.message:"Unknown error"},{status:500})}}e.s(["POST",()=>E],46345);var w=e.i(46345);let y=new t.AppRouteRouteModule({definition:{kind:r.RouteKind.APP_ROUTE,page:"/api/generar-preguntas/route",pathname:"/api/generar-preguntas",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/academia-santafe/app/api/generar-preguntas/route.ts",nextConfigOutput:"standalone",userland:w}),{workAsyncStorage:N,workUnitAsyncStorage:A,serverHooks:O}=y;function C(){return(0,a.patchFetch)({workAsyncStorage:N,workUnitAsyncStorage:A})}async function b(e,t,a){y.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let m="/api/generar-preguntas/route";m=m.replace(/\/index$/,"")||"/";let E=await y.prepare(e,t,{srcPage:m,multiZoneDraftMode:!1});if(!E)return t.statusCode=400,t.end("Bad Request"),null==a.waitUntil||a.waitUntil.call(a,Promise.resolve()),null;let{buildId:w,params:N,nextConfig:A,parsedUrl:O,isDraftMode:C,prerenderManifest:b,routerServerContext:S,isOnDemandRevalidate:T,revalidateOnlyGenerated:I,resolvedPathname:P,clientReferenceManifest:j,serverActionsManifest:k}=E,q=(0,l.normalizeAppPath)(m),_=!!(b.dynamicRoutes[q]||b.routes[P]),$=async()=>((null==S?void 0:S.render404)?await S.render404(e,t,O,!1):t.end("This page could not be found"),null);if(_&&!C){let e=!!b.routes[P],t=b.dynamicRoutes[q];if(t&&!1===t.fallback&&!e){if(A.experimental.adapterPath)return await $();throw new f.NoFallbackError}}let U=null;!_||y.isDev||C||(U="/index"===(U=P)?"/":U);let M=!0===y.isDev||!_,D=_&&!M;k&&j&&(0,s.setReferenceManifestsSingleton)({page:m,clientReferenceManifest:j,serverActionsManifest:k,serverModuleMap:(0,i.createServerModuleMap)({serverActionsManifest:k})});let H=e.method||"GET",L=(0,o.getTracer)(),F=L.getActiveScopeSpan(),K={params:N,prerenderManifest:b,renderOpts:{experimental:{authInterrupts:!!A.experimental.authInterrupts},cacheComponents:!!A.cacheComponents,supportsDynamicResponse:M,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:A.cacheLife,waitUntil:a.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,a)=>y.onRequestError(e,t,a,S)},sharedContext:{buildId:w}},J=new p.NodeNextRequest(e),B=new p.NodeNextResponse(t),G=c.NextRequestAdapter.fromNodeNextRequest(J,(0,c.signalFromNodeResponse)(t));try{let s=async e=>y.handle(G,K).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=L.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==d.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=r.get("next.route");if(a){let t=`${H} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${H} ${m}`)}),i=!!(0,n.getRequestMeta)(e,"minimalMode"),l=async n=>{var o,l;let p=async({previousCacheEntry:r})=>{try{if(!i&&T&&I&&!r)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let o=await s(n);e.fetchMetrics=K.renderOpts.fetchMetrics;let l=K.renderOpts.pendingWaitUntil;l&&a.waitUntil&&(a.waitUntil(l),l=void 0);let p=K.renderOpts.collectedTags;if(!_)return await (0,x.sendResponse)(J,B,o,K.renderOpts.pendingWaitUntil),null;{let e=await o.blob(),t=(0,g.toNodeOutgoingHttpHeaders)(o.headers);p&&(t[R.NEXT_CACHE_TAGS_HEADER]=p),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==K.renderOpts.collectedRevalidate&&!(K.renderOpts.collectedRevalidate>=R.INFINITE_CACHE)&&K.renderOpts.collectedRevalidate,a=void 0===K.renderOpts.collectedExpire||K.renderOpts.collectedExpire>=R.INFINITE_CACHE?void 0:K.renderOpts.collectedExpire;return{value:{kind:v.CachedRouteKind.APP_ROUTE,status:o.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:a}}}}catch(t){throw(null==r?void 0:r.isStale)&&await y.onRequestError(e,t,{routerKind:"App Router",routePath:m,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:D,isOnDemandRevalidate:T})},S),t}},c=await y.handleResponse({req:e,nextConfig:A,cacheKey:U,routeKind:r.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:b,isRoutePPREnabled:!1,isOnDemandRevalidate:T,revalidateOnlyGenerated:I,responseGenerator:p,waitUntil:a.waitUntil,isMinimalMode:i});if(!_)return null;if((null==c||null==(o=c.value)?void 0:o.kind)!==v.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==c||null==(l=c.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});i||t.setHeader("x-nextjs-cache",T?"REVALIDATED":c.isMiss?"MISS":c.isStale?"STALE":"HIT"),C&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let d=(0,g.fromNodeOutgoingHttpHeaders)(c.value.headers);return i&&_||d.delete(R.NEXT_CACHE_TAGS_HEADER),!c.cacheControl||t.getHeader("Cache-Control")||d.get("Cache-Control")||d.set("Cache-Control",(0,h.getCacheControlHeader)(c.cacheControl)),await (0,x.sendResponse)(J,B,new Response(c.value.body,{headers:d,status:c.value.status||200})),null};F?await l(F):await L.withPropagatedContext(e.headers,()=>L.trace(d.BaseServerSpan.handleRequest,{spanName:`${H} ${m}`,kind:o.SpanKind.SERVER,attributes:{"http.method":H,"http.target":e.url}},l))}catch(t){if(t instanceof f.NoFallbackError||await y.onRequestError(e,t,{routerKind:"App Router",routePath:q,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:D,isOnDemandRevalidate:T})}),_)throw t;return await (0,x.sendResponse)(J,B,new Response(null,{status:500})),null}}e.s(["handler",()=>b,"patchFetch",()=>C,"routeModule",()=>y,"serverHooks",()=>O,"workAsyncStorage",()=>N,"workUnitAsyncStorage",()=>A],21564)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__3ace3d98._.js.map